<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_custom_light</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// var

surface_light = surface_create(view_wview[0],view_hview[0]);
surface_ambience = surface_create(view_wview[0],view_hview[0]);

editing = false;
rotating = false;
scaling = false;
moving = false;
shading = false;
infodisp = 0;
scroll_point = 1;
saved = false;


// temp vars
hue = 0;
saturation = 0;
value = 225;
pointer_mode = 0; // 0 free | 1 snap x | 2 snap y | 3 snap x/y
shadow_point = 1; // editing | 1st point | 2nd point | 3rd point

pointer_x = 0;
pointer_y = 0;

// ###########################################
// ###########################################
// preferences
type = 0;
x_scale = 1;
y_scale = 1;
angle = 0;
color = make_colour_hsv(0,0,225);
light = 1;                  // lights 
ambience = 0;               // amount of ambient
light_shadow = 0.5;         // strength of light shadow
ambience_shadow = 0.5;      // strenfth of ambience shadow

// ###########################################
// ###########################################
// ds list for shadows
shadows = ds_list_create();
masks = ds_list_create();
sh_count = 0;
ms_count = 0;
sh_point_1_x = x;
sh_point_1_y = y;
sh_point_2_x = x;
sh_point_2_y = y;
sh_point_3_x = x;
sh_point_3_y = y;


</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// TOOL SETTINGS

snap = 32; // the tool will snap to a 32 pixel grid.

key_exit = vk_escape; // exit the edit mode
key_enter = vk_enter; // for saving shadows and masks to arrays
key_end = vk_end; // submit selected lights parameter string
key_backspace = vk_backspace;
key_delete = vk_delete;

key_mod_lcontrol = vk_lcontrol; // ctrl + D for copying lights
key_mod_lshift = vk_lshift; // value modifiers 

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// CLEAR FROM MEMORY

/*
destroy the ds_list on surfaces to prevent memory leaks
*/

if (surface_exists(surface_light)){
    surface_free(surface_light);
}
if (surface_exists(surface_ambience)){
    surface_free(surface_ambience);
}

if (ds_exists(shadows, ds_type_list)){
    ds_list_destroy(shadows);
}
if (ds_exists(masks, ds_type_list)){
    ds_list_destroy(masks);
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// CLEAR FROM MEMORY

/*
destroy the ds_list on surfaces to prevent memory leaks
*/

ds_list_destroy(shadows);
ds_list_destroy(masks);

surface_free(surface_light);
surface_free(surface_ambience);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="3">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// CLEAR FROM MEMORY

/*
destroy the ds_list on surfaces to prevent memory leaks
*/

if (surface_exists(surface_light)){
    surface_free(surface_light);
}
if (surface_exists(surface_ambience)){
    surface_free(surface_ambience);
}

if (ds_exists(shadows, ds_type_list)){
    ds_list_destroy(shadows);
}
if (ds_exists(masks, ds_type_list)){
    ds_list_destroy(masks);
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="73">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// GUI

// make sure all surfaces exit
if (!surface_exists(surface_light)){surface_light = surface_create(view_wview[0], view_hview[0])}
if (!surface_exists(surface_ambience)){surface_ambience = surface_create(view_wview[0], view_hview[0])}


// #################################################################################################
// #################################################################################################
// #################################################################################################
// as in dev mode


if (global.light_dev_mode == true){


        // icon
        if (saved == false){draw_set_colour(c_white)}
        else {draw_set_colour(c_green);}
        draw_circle(x,y,11,0);
        draw_rectangle(x-3,y,x+4,y+18,0); 

        // toggle edit mode
        if ( point_distance(mouse_x,mouse_y,x,y) &lt; 30 ) {
            draw_circle(x,y,30,1);
            
            if (mouse_check_button_pressed(mb_left)) {
                if (global.light_dev_edit == false &amp;&amp; editing = false){
                    editing = true;
                    global.light_dev_edit = true;
                }
            }
        }
        
        // cancel the edit
        if (keyboard_check_pressed(key_exit)){
            global.light_dev_edit = false;
            editing = false;
            shading = false;
            
            // clear vars
            pointer_x = x;
            pointer_y = y;
            
            sh_point_1_x = x;
            sh_point_1_y = y;
            sh_point_2_x = x;
            sh_point_2_y = y;
            sh_point_3_x = x;
            sh_point_3_y = y;
        }
        
//////////////  //////////////  //////////////  //////////////  //////////////  //////////////  
//////////////  //////////////  //////////////  //////////////  //////////////  //////////////  
//////////////  //////////////  //////////////  //////////////  //////////////  ////////////// 
    
    if (editing = true){
    
        // duplicate the light
        if (keyboard_check(key_mod_lcontrol) &amp;&amp; keyboard_check_pressed(ord("D"))){
            duplicate = instance_create(x+32, y+32, obj_amb_kit_light){
                duplicate.type = type;
                duplicate.x_scale = x_scale;
                duplicate.y_scale = y_scale;
                duplicate.angle = angle;
                duplicate.hue = hue;
                duplicate.saturation = saturation;
                duplicate.value = value;
                duplicate.light = light;
                duplicate.ambience = ambience;
                duplicate.light_shadow = light_shadow;
                duplicate.ambience_shadow = ambience_shadow;
                
                duplicate.sh_count = sh_count;
                duplicate.ms_count = ms_count;
                
                
                with(duplicate){
                    ds_list_copy( shadows, other.shadows );
                    ds_list_copy( masks, other.masks );
                    editing = true;
                }
            }
            //global.light_dev_edit = false;            
            editing = false;
            shading = false;  
        }
        
        // delete light
        if (keyboard_check_pressed(key_delete)){
            global.light_dev_edit = false;  
            instance_destroy();
        }
        
//////////////  //////////////  //////////////  //////////////  //////////////  //////////////  
//////////////  //////////////  //////////////  //////////////  //////////////  //////////////  
//////////////  //////////////  //////////////  //////////////  //////////////  ////////////// 
        
        // moving
        draw_set_halign(fa_center);
        draw_set_color(c_black)
        draw_text(x-70+1, y-20+1, "x/y move");
        draw_set_color(c_red)
        draw_circle(x-70, y, 6, 0);
        draw_text(x-70, y-20, "x/y move");

        if (point_distance(mouse_x,mouse_y,x-70,y) &lt; 6 &amp;&amp; mouse_check_button_pressed(mb_left)){
            moving = true;
        }
        if (mouse_check_button_released(mb_left)){
            moving = false;
        }
        if (moving = true){
            x = mouse_x+70;
            y = mouse_y;
        }
        
        // rotation
        draw_set_halign(fa_center);
        draw_set_color(c_black);
        draw_text(x+1, y+30+1, "rotate");
        draw_set_color(c_red)
        draw_circle(x, y+50, 6, 0);
        draw_text(x, y+30, "rotate");
        if (point_distance(mouse_x,mouse_y,x,y+50) &lt; 6 &amp;&amp; mouse_check_button_pressed(mb_left)){
            rotating = true;
        }
        if (mouse_check_button_released(mb_left)){
            rotating = false;
        }
        if (rotating = true){
            if (keyboard_check(key_mod_lshift)){
                angle = floor((point_direction(x,y,mouse_x,mouse_y)+90) / 22.5) * 22.5;
            }
            else {
                angle = point_direction(x,y,mouse_x,mouse_y)+90;
            }
        }
        
        // shadows
        draw_set_halign(fa_center);
        draw_set_color(c_black)
        draw_text(x+1, y-70+1, "'E' shadows");
        if (shading = false){draw_set_color(c_black);}
        else {
            draw_set_color(c_green);
            draw_circle(x, y-50, 7+random(3), 0);
        }
        draw_set_color(c_green)
        draw_circle(x, y-50, 6, 0);

        draw_text(x, y-70, "'E' shadows");
        // toggle shading mode
        if (keyboard_check_pressed(ord("E"))){
            if (shading = false){shading = true;}
            else {shading = false;}
        }
        
        // scaling / scale
        draw_set_color(c_black)        
        draw_text(x+70+1, y-20+1, "x/y scale")
        draw_set_color(c_red)
        draw_circle(x+70, y, 6, 0);
        draw_text(x+70, y-20, "x/y scale")
        if (point_distance(mouse_x, mouse_y, x+70, y) &lt; 6 &amp;&amp; mouse_check_button_pressed(mb_left)){
            scaling = true;
        }
        if (mouse_check_button_released(mb_left)){
            scaling = false;
        }
        if (scaling = true){
            if (keyboard_check(key_mod_lshift)){
                x_scale = point_distance(x,y,mouse_x,mouse_y) / 200;
                y_scale = point_distance(x,y,mouse_x,mouse_y) / 200; 
            }
            else {
                x_scale = ((x - mouse_x) / 100) * -1;
                y_scale = ((y - mouse_y) / 100) * -1;
            }
        }
        
//////////////  //////////////  //////////////  //////////////  //////////////  //////////////  
//////////////  //////////////  //////////////  //////////////  //////////////  //////////////  
//////////////  //////////////  //////////////  //////////////  //////////////  ////////////// 
        
        // button edits
        // type
        if (keyboard_check_pressed(ord("1"))){
            if (type &lt; sprite_get_number(spr_custom_lights_light)-1){type++;}
            else {type = 0;}
        }
        // hue
        if (keyboard_check(ord("2"))){
            hue = abs((x - mouse_x))-30;
            if (hue &lt; 0) {hue = 0;}
            if (hue &gt; 255) {hue = 255;}
        }
        // saturation
        if (keyboard_check(ord("3"))){
            saturation = abs((x - mouse_x))-30;
            if (saturation &lt; 0) {saturation = 0;}
            if (saturation &gt; 255) {saturation = 255;}           
        }
        // value
        if (keyboard_check(ord("4"))){
            value = abs((x - mouse_x))-30;
            if (value &lt; 0) {value = 0;}
            if (value &gt; 255) {value = 255;}                      
        }
        // light
        if (keyboard_check(ord("5"))){ 
            light = (abs((x - mouse_x))-30) / 200;  
            if (light &lt; 0) {light = 0;}
            if (light &gt; 1) {light = 1;}       
        }       
        // ambience
        if (keyboard_check(ord("6"))){ 
            ambience = (abs((x - mouse_x))-30) / 200;   
            if (ambience &lt; 0) {ambience = 0;}
            if (ambience &gt; 1) {ambience = 1;}                  
        }       
        // light shadow
        if (keyboard_check(ord("7"))){ 
            light_shadow = (abs((x - mouse_x))-30) / 200;   
            if (light_shadow &lt; 0) {light_shadow = 0;}
            if (light_shadow &gt; 1) {light_shadow = 1;}                   
        }       
        // ambience shadow
        if (keyboard_check(ord("8"))){
            ambience_shadow = (abs((x - mouse_x))-30) / 200;  
            if (ambience_shadow &lt; 0) {ambience_shadow = 0;}
            if (ambience_shadow &gt; 1) {ambience_shadow = 1;}                     
        }       
         
//////////////  //////////////  //////////////  //////////////  //////////////  //////////////  
//////////////  //////////////  //////////////  //////////////  //////////////  //////////////  
//////////////  //////////////  //////////////  //////////////  //////////////  ////////////// 
        
        // shadows
        if (shading = true){
            if mouse_check_button_pressed(mb_right){
                pointer_mode++;
                if (pointer_mode &gt; 5) {pointer_mode = 0;}
            }
            
            // pointer and ray
            draw_set_color(c_red);
            draw_line(x,y,mouse_x,mouse_y);
            // mouse locator
            draw_circle(mouse_x, mouse_y, 25, 1);
            
            // pick snap method
            // free
            if (pointer_mode == 0){ 
                pointer_x = mouse_x;
                pointer_y = mouse_y;
                draw_text(mouse_x,mouse_y-55,"snap: free");
            }
            // snap x
            else if (pointer_mode == 1){
                pointer_x = floor((mouse_x/snap))*snap;
                pointer_y = mouse_y;
                draw_text(mouse_x,mouse_y-55,"snap: vert");
            }
            // snap y
            else if (pointer_mode == 2){
                pointer_x = mouse_x;
                pointer_y = floor((mouse_y/snap))*snap;
                draw_text(mouse_x,mouse_y-55,"snap: hor");
            }
            // snap x/y
            else if (pointer_mode == 3){
                pointer_x = floor((mouse_x/snap))*snap;
                pointer_y = floor((mouse_y/snap))*snap;
                draw_text(mouse_x,mouse_y-55,"snap: both");
            }
            // snap to previously written ds_list point
            else if (pointer_mode == 4 &amp;&amp; sh_count &gt; 0){
                if(keyboard_check(key_mod_lshift)){
                    if (mouse_wheel_down()){scroll_point++;}
                    if (mouse_wheel_up()){scroll_point--;}
                }
                if (scroll_point &lt; 0){scroll_point = 0;}
                if (scroll_point &gt; (ds_list_size(shadows)/2)-1){scroll_point--;}
                pointer_x = ds_list_find_value(shadows, 1+(2*scroll_point));
                pointer_y = ds_list_find_value(shadows, 2+(2*scroll_point));
                draw_text(mouse_x,mouse_y-55,"snap: shadow points");
            }
            // snap to previously written ds_list point
            else if (pointer_mode == 5 &amp;&amp; ms_count &gt; 0){
                if(keyboard_check(key_mod_lshift)){
                    if (mouse_wheel_down()){scroll_point++;}
                    if (mouse_wheel_up()){scroll_point--;}
                }
                if (scroll_point &lt; 0){scroll_point = 0;}
                if (scroll_point &gt; (ds_list_size(masks)/2)-1){scroll_point--;}
                pointer_x = ds_list_find_value(masks, 1+(2*scroll_point));
                pointer_y = ds_list_find_value(masks, 2+(2*scroll_point));
                draw_text(mouse_x,mouse_y-55,"snap: mask points");
            }
            else {
                pointer_mode = 0;
            }
                     
            // snap position
            draw_circle(pointer_x, pointer_y, 20, 1);
            draw_line_width(pointer_x-20, pointer_y, pointer_x+20, pointer_y, 1);
            draw_line_width(pointer_x, pointer_y-20, pointer_x, pointer_y+20, 1);
            
            // temp current shadow triangle
            draw_set_alpha(0.2);
            draw_set_color(c_red);
            draw_triangle(sh_point_1_x,sh_point_1_y, sh_point_2_x,sh_point_2_y, sh_point_3_x,sh_point_3_y, 0);
            draw_set_alpha(1);
            draw_text(sh_point_1_x,sh_point_1_y,"pt 1");
            draw_text(sh_point_2_x,sh_point_2_y,"pt 2");
            draw_text(sh_point_3_x,sh_point_3_y,"pt 3");
            draw_set_color(c_black);
            
            // cycle through points to edit
            if (mouse_wheel_down()) {
                if (pointer_mode == 4){
                    if(!keyboard_check(key_mod_lshift)){shadow_point++;}
                }
                else {
                    shadow_point++;
                }
            }
            if (mouse_wheel_up()) {
                if (pointer_mode == 4){
                    if(!keyboard_check(key_mod_lshift)){shadow_point--;}
                }
                else {
                    shadow_point--;
                }
            }
            
            
            if (shadow_point &lt; 1) {shadow_point = 1;}
            if (shadow_point &gt; 3) {shadow_point = 3;}
            
            // edit shadow triangle
            draw_set_color(c_red);
                        
//////////////  //////////////  //////////////  //////////////  //////////////  //////////////  
//////////////  //////////////  //////////////  //////////////  //////////////  //////////////  
//////////////  //////////////  //////////////  //////////////  //////////////  ////////////// 

            // set 3 points of the    
            switch shadow_point {
                case 1:
                    draw_text(mouse_x,mouse_y-40,"x:" + string(pointer_x) + " y:" + string(pointer_y) + " pnt: 1")
                    if (mouse_check_button(mb_left)){
                        sh_point_1_x = pointer_x;
                        sh_point_1_y = pointer_y;
                    }

                break;
                case 2:
                    draw_text(mouse_x,mouse_y-40,"x:" + string(pointer_x) + " y:" + string(pointer_y) + " pnt: 2")
                    if (mouse_check_button(mb_left)){
                        sh_point_2_x = pointer_x;
                        sh_point_2_y = pointer_y;
                    }
                break;
                case 3:
                    draw_text(mouse_x,mouse_y-40,"x:" + string(pointer_x) + " y:" + string(pointer_y) + " pnt: 3")
                    if (mouse_check_button(mb_left)){
                        sh_point_3_x = pointer_x;
                        sh_point_3_y = pointer_y;
                    }
                break;
            }
            
//////////////  //////////////  //////////////  //////////////  //////////////  //////////////  
//////////////  //////////////  //////////////  //////////////  //////////////  //////////////  
//////////////  //////////////  //////////////  //////////////  //////////////  //////////////  
            
            // save shadows to ds_list
            if (!keyboard_check(key_mod_lshift) &amp;&amp; keyboard_check_pressed(key_enter)){
                // if light is new and no shadows have been written, add shadow count as first value
                if (sh_count = 0){
                    sh_count++;
                    ds_list_add(shadows, sh_count);
                }
                // else if this is not the first shadow, replace the first value with shadow count
                else {
                    sh_count++;
                    ds_list_replace(shadows, 0, sh_count);
                }
                
                // write down the 3 shadow points 
                ds_list_add(shadows, sh_point_1_x,sh_point_1_y, sh_point_2_x,sh_point_2_y, sh_point_3_x,sh_point_3_y);
                // reset which point is being made
                shadow_point = 1;
            }
            
            // save mask to ds_list
            if (keyboard_check(key_mod_lshift) &amp;&amp; keyboard_check_pressed(key_enter)){
                // if mask is new and no masks have been written, add mask count as first value
                if (ms_count = 0){
                    ms_count++;
                    ds_list_add(masks, ms_count);
                }
                // else if this is not the first mask, replace the first value with mask count
                else {
                    ms_count++;
                    ds_list_replace(masks, 0, ms_count);
                }
                
                // write down the 3 mask points 
                ds_list_add(masks, sh_point_1_x,sh_point_1_y, sh_point_2_x,sh_point_2_y, sh_point_3_x,sh_point_3_y);
                // reset which point is being made
                shadow_point = 1;  
            }
                        
            // clear shadows ds_list
            if (!keyboard_check(key_mod_lshift) &amp;&amp; keyboard_check_pressed(key_backspace)){
                ds_list_clear(shadows);
                sh_count = 0;
            }

            // clear masks ds_list
            if (keyboard_check(key_mod_lshift) &amp;&amp; keyboard_check_pressed(key_backspace)){
                ds_list_clear(masks);
                ms_count = 0;
            }
            
            //draw the debug shadows in red
            draw_set_colour(c_red);
            draw_set_alpha(0.2);
            for(xx=0; xx&lt;ds_list_find_value(shadows, 0); xx++){
                draw_triangle(ds_list_find_value(shadows, 1+(6*xx)),
                              ds_list_find_value(shadows, 2+(6*xx)),
                              ds_list_find_value(shadows, 3+(6*xx)),
                              ds_list_find_value(shadows, 4+(6*xx)),
                              ds_list_find_value(shadows, 5+(6*xx)),
                              ds_list_find_value(shadows, 6+(6*xx)),
                              0);
            }
            draw_set_colour(c_white);
            draw_set_alpha(1);
            
            
            //draw the debug masks in green
            draw_set_colour(c_lime);
            draw_set_alpha(0.2);
            for(xx=0; xx&lt;ds_list_find_value(masks, 0); xx++){
                draw_triangle(ds_list_find_value(masks, 1+(6*xx)),
                              ds_list_find_value(masks, 2+(6*xx)),
                              ds_list_find_value(masks, 3+(6*xx)),
                              ds_list_find_value(masks, 4+(6*xx)),
                              ds_list_find_value(masks, 5+(6*xx)),
                              ds_list_find_value(masks, 6+(6*xx)),
                              0);
            }
            draw_set_colour(c_white);
            draw_set_alpha(1);
        } // end of shadow edit mode
        
        // scale/rotate frame
        draw_sprite_ext(spr_custom_boundary,0,x,y,x_scale,y_scale,angle,c_white,1);

//////////////  //////////////  //////////////  //////////////  //////////////  //////////////  
//////////////  //////////////  //////////////  //////////////  //////////////  //////////////  
//////////////  //////////////  //////////////  //////////////  //////////////  //////////////         
                
        // GUI
        // toggle info displace
        if (keyboard_check_pressed(ord("Q"))){
            if (infodisp &lt; 2) {infodisp++;}
            else {infodisp = 0;}
        }
        
        draw_circle(x,y,30,1);
        if (infodisp == 1 || infodisp == 2){ 
            
            draw_set_color(c_black);
            draw_set_alpha(0.8);
            draw_rectangle(view_xview[0], view_yview[0]+view_hview[0]-280, view_xview[0]+560, view_yview[0]+view_hview, 0);
            draw_set_color(c_white);
            draw_set_alpha(1);
            
            // numbers
            m = 270; 
            dis = 20;
            draw_set_halign(fa_left);
            draw_set_colour(c_white);
            draw_text(view_xview[0]+dis, view_yview[0]+view_hview[0]-m,      "key 1: type");
            draw_text(view_xview[0]+dis, view_yview[0]+view_hview[0]-m+20,   "x pos");
            draw_text(view_xview[0]+dis, view_yview[0]+view_hview[0]-m+40,   "y pos");
            draw_text(view_xview[0]+dis, view_yview[0]+view_hview[0]-m+60,   "x scale");
            draw_text(view_xview[0]+dis, view_yview[0]+view_hview[0]-m+80,   "y scale");
            draw_text(view_xview[0]+dis, view_yview[0]+view_hview[0]-m+100,  "angle");
            draw_set_color(c_orange);
            draw_text(view_xview[0]+dis, view_yview[0]+view_hview[0]-m+120,  "key 2: hue [0-256]");
            draw_text(view_xview[0]+dis, view_yview[0]+view_hview[0]-m+140,  "key 3: saturation [0-256]");
            draw_text(view_xview[0]+dis, view_yview[0]+view_hview[0]-m+160,  "key 4: value [0-256]");
            draw_set_color(c_aqua);
            draw_text(view_xview[0]+dis, view_yview[0]+view_hview[0]-m+180,  "key 5: lght [0.0-1.0]");
            draw_text(view_xview[0]+dis, view_yview[0]+view_hview[0]-m+200,  "key 6: amb [0.0-1.0]");
            draw_set_color(c_teal);
            draw_text(view_xview[0]+dis, view_yview[0]+view_hview[0]-m+220,  "key 7: lght sh [0.0-1.0]");
            draw_text(view_xview[0]+dis, view_yview[0]+view_hview[0]-m+240,  "key 8: amb sh [0.0-1.0]");
            draw_set_color(c_white);
            
            dis = 240;
            draw_set_color(c_gray);
            draw_text(view_xview[0]+dis, view_yview[0]+view_hview[0]-m,      "(" + string(type) +           ")");
            draw_text(view_xview[0]+dis, view_yview[0]+view_hview[0]-m+20,   "(" + string(x) +              ")");
            draw_text(view_xview[0]+dis, view_yview[0]+view_hview[0]-m+40,   "(" + string(y) +              ")");
            draw_text(view_xview[0]+dis, view_yview[0]+view_hview[0]-m+60,   "(" + string(x_scale) +        ")");
            draw_text(view_xview[0]+dis, view_yview[0]+view_hview[0]-m+80,   "(" + string(y_scale) +        ")");
            draw_text(view_xview[0]+dis, view_yview[0]+view_hview[0]-m+100,  "(" + string(angle) +          ")");
            draw_text(view_xview[0]+dis, view_yview[0]+view_hview[0]-m+120,  "(" + string(hue) +            ")");
            draw_text(view_xview[0]+dis, view_yview[0]+view_hview[0]-m+140,  "(" + string(saturation) +     ")");
            draw_text(view_xview[0]+dis, view_yview[0]+view_hview[0]-m+160,  "(" + string(value) +          ")");
            draw_text(view_xview[0]+dis, view_yview[0]+view_hview[0]-m+180,  "(" + string(light) +          ")");
            draw_text(view_xview[0]+dis, view_yview[0]+view_hview[0]-m+200,  "(" + string(ambience) +       ")");
            draw_text(view_xview[0]+dis, view_yview[0]+view_hview[0]-m+220,  "(" + string(light_shadow) +   ")");
            draw_text(view_xview[0]+dis, view_yview[0]+view_hview[0]-m+240,  "(" + string(ambience_shadow) +")");
            draw_set_color(c_white);
            
                                    
            dis = 320;
            draw_text(view_xview[0]+dis, view_yview[0]+view_hview[0]-m,         "point_1: x: " + string(sh_point_1_x) + " y: " + string(sh_point_1_y));
            draw_text(view_xview[0]+dis, view_yview[0]+view_hview[0]-m+20,      "point_2: x: " + string(sh_point_2_x) + " y: " + string(sh_point_2_y));
            draw_text(view_xview[0]+dis, view_yview[0]+view_hview[0]-m+40,      "point_3: x: " + string(sh_point_3_x) + " y: " + string(sh_point_3_y));
            draw_text(view_xview[0]+dis, view_yview[0]+view_hview[0]-m+60,      "Shadow Count: " + string(sh_count));
            draw_text(view_xview[0]+dis, view_yview[0]+view_hview[0]-m+80,      "Shadow in ds_list: " + string(abs(floor(ds_list_size(shadows)-1)/6)));
            draw_text(view_xview[0]+dis, view_yview[0]+view_hview[0]-m+100,     "Mask Count: " + string(ms_count));
            draw_text(view_xview[0]+dis, view_yview[0]+view_hview[0]-m+120,     "Masks in ds_list: " + string(abs(floor(ds_list_size(masks)-1)/6)));
            

        }
        
        if (infodisp == 2){
        
            draw_set_color(c_black);
            draw_set_alpha(0.8);
            draw_rectangle(view_xview[0], view_yview[0]+view_hview[0]-290, view_xview[0]+560, view_yview[0]+view_hview-550, 0);
            draw_set_color(c_white);
            draw_set_alpha(1);
        
            dis = 20;
            m = 620;     
            draw_set_colour(c_white);
            draw_text(view_xview[0]+dis, view_yview[0]+view_hview[0]-m+80,     "'Q' toggle info menus");       
            draw_set_colour(c_green);
            draw_text(view_xview[0]+dis, view_yview[0]+view_hview[0]-m+100,     "'E' shadow edit mode | [right mouse btn for snap modes]");
            draw_text(view_xview[0]+dis, view_yview[0]+view_hview[0]-m+120,     "'Enter' save shadow, 'Shift + Enter' save mask");
            draw_text(view_xview[0]+dis, view_yview[0]+view_hview[0]-m+140,     "'Backspace' clear shadows, 'Shift + Backspace' clear mask");
            draw_text(view_xview[0]+dis, view_yview[0]+view_hview[0]-m+160,     "'Mouse Scroll' select current edit points");
            draw_text(view_xview[0]+dis, view_yview[0]+view_hview[0]-m+180,     "'Shift + Mouse Scroll' select saved shadow point");
            draw_set_colour(c_gray);
            draw_text(view_xview[0]+dis, view_yview[0]+view_hview[0]-m+200,     "'Hold 'Shift' when scaling or rotating for snap");
            draw_text(view_xview[0]+dis, view_yview[0]+view_hview[0]-m+220,     "'Crtl + D' duplicate light (must have a light selected)");
            draw_text(view_xview[0]+dis, view_yview[0]+view_hview[0]-m+240,     "'Del' delete selected light");
            draw_text(view_xview[0]+dis, view_yview[0]+view_hview[0]-m+260,     "'Ins' create decault light at mouse position");
            draw_set_colour(c_red);
            draw_text(view_xview[0]+dis, view_yview[0]+view_hview[0]-m+280,     "'End' save only selected light | insert result to each light");
            draw_text(view_xview[0]+dis, view_yview[0]+view_hview[0]-m+300,     "'Home' save entire system | insert result to master layer");
            draw_set_color(c_white);
            
        }
        
        if (keyboard_check_pressed(key_end)){
            // show as saved
            saved = true;
            
            // creation code template
            show_debug_message("// ####################################################");
            show_debug_message("// ####################################################");
            show_debug_message(" ");
            define = get_string("Note the description of this light source", "Identify this light"); 
            show_debug_message("Description = '" + string(define) + "';");
            show_debug_message(" ");
            show_debug_message("type = " + string(type) + ";");
            show_debug_message("x = " + string(x) + ";")
            show_debug_message("y = " + string(y) + ";");
            show_debug_message("x_scale = " + string(x_scale) + ";");
            show_debug_message("y_scale = " + string(y_scale) + ";");
            show_debug_message("angle = " + string(angle) + ";");
            show_debug_message("hue = " + string(hue) + ";");
            show_debug_message("saturation = " + string(saturation) + ";");
            show_debug_message("value = " + string(value) + ";");
            show_debug_message("light = " + string(light) + ";");
            show_debug_message("ambience = " + string(ambience) + ";");
            show_debug_message("light_shadow = " + string(light_shadow) + ";");
            show_debug_message("ambience_shadow = " + string(ambience_shadow) + ";");
            show_debug_message(" ");
            show_debug_message(" ");
            show_debug_message("// shadows ds map");
            show_debug_message("ds_list_read(shadows, '" + ds_list_write(shadows) + "');");
            show_debug_message(" ");
            show_debug_message(" ");
            show_debug_message("// masks ds map ");
            show_debug_message("ds_list_read(masks, '" + ds_list_write(masks) + "');");
            show_debug_message(" ");
            show_debug_message("// ####################################################");
            show_debug_message("// ####################################################");


        }
    } // end of "if this light id being edited"
    
} // end of if in dev mode
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// apply the shadows and masks to surfaces

// #################################################################################################
// #################################################################################################
// #################################################################################################
// as a standard object not in dev mode prepare the shadows

// make hsv color from hue / saturation / value
color = make_colour_hsv(hue, saturation, value);

// lights and shadows
surface_set_target(surface_light);
    draw_clear_alpha(c_white, 0);
    draw_sprite_ext(spr_custom_lights_light, type, x-view_xview[0], y-view_yview[0], x_scale, y_scale, angle, c_white, light);
    
    draw_set_blend_mode(bm_src_color);
    draw_set_alpha(light_shadow);
    draw_set_color(c_black);
    for(xx=0; xx&lt;ds_list_find_value(shadows, 0); xx++){
        // apply shadows
        draw_triangle(ds_list_find_value(shadows, 1+(6*xx))-view_xview[0],
                      ds_list_find_value(shadows, 2+(6*xx))-view_yview[0],
                      ds_list_find_value(shadows, 3+(6*xx))-view_xview[0],
                      ds_list_find_value(shadows, 4+(6*xx))-view_yview[0],
                      ds_list_find_value(shadows, 5+(6*xx))-view_xview[0],
                      ds_list_find_value(shadows, 6+(6*xx))-view_yview[0],
                      0);
    }
    
    // subtract masks   
    draw_set_alpha(1); 
    for(xx=0; xx&lt;ds_list_find_value(masks, 0); xx++){  
        draw_triangle(ds_list_find_value(masks, 1+(6*xx))-view_xview[0],
                      ds_list_find_value(masks, 2+(6*xx))-view_yview[0],
                      ds_list_find_value(masks, 3+(6*xx))-view_xview[0],
                      ds_list_find_value(masks, 4+(6*xx))-view_yview[0],
                      ds_list_find_value(masks, 5+(6*xx))-view_xview[0],
                      ds_list_find_value(masks, 6+(6*xx))-view_yview[0],
                      0);
    }
    
    draw_set_alpha(1);
    draw_set_blend_mode(bm_normal);
surface_reset_target();


// ambience and shadows.
surface_set_target(surface_ambience);
    draw_clear_alpha(c_black, 0);
    draw_sprite_ext(spr_custom_lights_blend, type, x-view_xview[0], y-view_yview[0], x_scale, y_scale, angle, color, ambience);
    
    draw_set_blend_mode(bm_src_colour);
    draw_set_alpha(ambience_shadow);
    draw_set_color(c_black);
    for(xx=0; xx&lt;ds_list_find_value(shadows, 0); xx++){
        // apply shadows
        draw_triangle(ds_list_find_value(shadows, 1+(6*xx))-view_xview[0],
                      ds_list_find_value(shadows, 2+(6*xx))-view_yview[0],
                      ds_list_find_value(shadows, 3+(6*xx))-view_xview[0],
                      ds_list_find_value(shadows, 4+(6*xx))-view_yview[0],
                      ds_list_find_value(shadows, 5+(6*xx))-view_xview[0],
                      ds_list_find_value(shadows, 6+(6*xx))-view_yview[0],
                      0);
    }

    // subtract masks
    draw_set_alpha(1);
    for(xx=0; xx&lt;ds_list_find_value(masks, 0); xx++){        
        draw_triangle(ds_list_find_value(masks, 1+(6*xx))-view_xview[0],
                      ds_list_find_value(masks, 2+(6*xx))-view_yview[0],
                      ds_list_find_value(masks, 3+(6*xx))-view_xview[0],
                      ds_list_find_value(masks, 4+(6*xx))-view_yview[0],
                      ds_list_find_value(masks, 5+(6*xx))-view_xview[0],
                      ds_list_find_value(masks, 6+(6*xx))-view_yview[0],
                      0);
    }
    
    draw_set_alpha(1);
    draw_set_blend_mode(bm_normal);
    draw_set_color(c_white);
surface_reset_target();
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>16,16</point>
    <point>16,16</point>
  </PhysicsShapePoints>
</object>
